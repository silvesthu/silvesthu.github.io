<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Indefinite Seven</title>
        <link>https://silvesthu.github.io/posts/</link>
        <description>Recent content in Posts on Indefinite Seven</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sun, 24 May 2020 07:45:52 +0900</lastBuildDate>
        <atom:link href="https://silvesthu.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>HLSL pitfalls</title>
            <link>https://silvesthu.github.io/posts/2020/05/hlsl-pitfalls/</link>
            <pubDate>Sun, 24 May 2020 07:45:52 +0900</pubDate>
            
            <guid>https://silvesthu.github.io/posts/2020/05/hlsl-pitfalls/</guid>
            <description>Have encountered several issues of HLSL.
Found most workaround/solution on internet.
I&#39;m afraid the list is still growing as I know more,
put them in one place could be helpful.
Denormalized float, small float/large uint This is a FXC only issue.
First, there is asfloat(0x7FFFFF) =&amp;gt; 0 from
Low-level Shader Optimization for Next-Gen and DX11 by Emil Persson.
That is, asfloat always gives 0 if you feed bits fit denormalized pattern.</description>
            <content type="html"><![CDATA[<p>Have encountered several issues of HLSL.<br>
Found most workaround/solution on internet.<br>
I'm afraid the list is still growing as I know more,<br>
put them in one place could be helpful.</p>
<h2 id="denormalized-float-small-floatlarge-uint">Denormalized float, small float/large uint</h2>
<p><strong>This is a FXC only issue.</strong></p>
<p>First, there is <code>asfloat(0x7FFFFF) =&gt; 0</code> from<br>
<a href="https://www.slideshare.net/DevCentralAMD/lowlevel-shader-optimization-for-nextgen-and-dx11-by-emil-persson">Low-level Shader Optimization for Next-Gen and DX11 by Emil Persson</a>.<br>
That is, <code>asfloat</code> always gives 0 if you feed bits fit denormalized pattern.</p>
<p>Then, floats smaller than 1e-6 won't make their way into output.<br>
<code>return 1e-7; =&gt; return 0;</code><br>
I wonder how one can write to a R32_FLOAT correctly.</p>
<p>Similarly, uint equal or larger than 0x00800000 (24 bit),<br>
<code>return 0x00800000; =&gt; return 0;</code></p>
<p>Unlike the denormalized case,<br>
small float/large uint stay alive during calculation.<br>
It only becomes problem when exporting them, to render target or UAV.</p>
<hr>
<h2 id="nonuniformresourceindex">NonUniformResourceIndex</h2>
<p>This is rather simple.<br>
<a href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/resource-binding-in-hlsl#resource-types-and-arrays">https://docs.microsoft.com/en-us/windows/win32/direct3d12/resource-binding-in-hlsl#resource-types-and-arrays</a><br>
One need to add the <code>NonUniformResourceIndex</code> when accessing array with non-uniform index.<br>
<code>tex1[NonUniformResourceIndex(myMaterialID)].Sample(samp[NonUniformResourceIndex(samplerID)], texCoords);</code></p>
<p>The evil part is, even if you don't follow compiler won't complain about it.<br>
Then you'll find it breaks on some GPUs.<br>
Further detail can be found here.<br>
<a href="https://www.asawicki.info/news_1608_direct3d_12_-_watch_out_for_non-uniform_resource_index">https://www.asawicki.info/news_1608_direct3d_12_-_watch_out_for_non-uniform_resource_index</a></p>
<hr>
<h2 id="wavereadlaneat">WaveReadLaneAt</h2>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/wavereadlaneat">https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/wavereadlaneat</a></p>
<blockquote>
<p>The input lane index must be uniform across the wave.<br>
This function is effectively a broadcast of the value in the laneIndex’th lane.</p>
</blockquote>
<p>But what happens if we pass non-uniform index to it? It works!<br>
Now That's confusing.<br>
Here's a sample on <a href="http://shader-playground.timjones.io/60ec03f77dfcbfa9f1951327cf80cede">Shader Playground</a>.</p>
<p>DXC gives<br>
<code>%6 = call i32 @dx.op.waveReadLaneAt.i32(i32 117, i32 %2, i32 %5)</code><br>
So my guess is DXC doesn't actually check whether a variable is uniform or not,<br>
thus no error reported.</p>
<p>So why the restriction in the first place?</p>
<p><a href="https://twitter.com/SebAaltonen/status/1095183824290484226">https://twitter.com/SebAaltonen/status/1095183824290484226</a></p>
<blockquote>
<p>WaveReadLaneAt must have wave uniform index. Docs say so. SM 6.0 wave intrinsics were modeled after GCN2 hardware (original Xbox One). GCN3 additions (DS_PERMUTE) and Nvidia/Intel equivalents are not exposed. GCN3+ and all Nvidia/Intel DX12 HW support full per lane stuffle.</p>
</blockquote>
<p>Turn out it need a specific instruction to perform on non-uniform index.<br>
And it becomes a shuffle rather than a broadcast.<br>
In GLSL/Vulkan, <code>subgroupBroadcast</code> and <code>subgroupShuffle</code> are well defined.<br>
<a href="https://www.khronos.org/assets/uploads/developers/library/2018-vulkan-devday/06-subgroups.pdf">HLSL/GLSL/SPRI-V mapping</a></p>
<p>On my Intel/Nvidia card, it behaves like a shuffle and results seem alright.<br>
I'm curious what will driver do if hardware just don't support shuffle.<br>
Luckily for AMD we have the <a href="https://github.com/GPUOpen-Tools/radeon_gpu_analyzer">Radeon GPU Analyzer</a>.<br>
For gfx1010, it generate <code>ds_bpermute_b32</code>, which is a shuffle as in the twitter thread.<br>
For gfx702, GCN2, the generated code is much longer. <a href="https://pastebin.com/gr0ivzg3">Pastebin</a>.</p>
<pre><code>// In HLSL it might look like this
// Every lane keeps checking till itself becomes the first lane, then do the actual work. Nice trick
while (true)
{
	if (WaveReadLaneFirst(SV_GroupThreadID) == SV_GroupThreadID)
	{
		uint uniform_index = WaveReadLaneFirst(divergent_index);
		output = WaveReadLaneAt(input, uniform_index);
		break;
	}
}
</code></pre><p>See full sample in <a href="http://shader-playground.timjones.io/2fc43f77f626c4883e1b1ed23fd8b2e1">Shader Playground</a><br>
Somehow an extra if is needed for DXC to generate a loop correctly&hellip;</p>
<hr>
<p>Hope this list won't grow too much in the future.</p>
]]></content>
        </item>
        
        <item>
            <title>Wave Intrinsics Hello World</title>
            <link>https://silvesthu.github.io/posts/2020/05/wave-intrinsics-hello-world/</link>
            <pubDate>Sat, 09 May 2020 00:51:14 +0900</pubDate>
            
            <guid>https://silvesthu.github.io/posts/2020/05/wave-intrinsics-hello-world/</guid>
            <description>After work with DirectX 12 for a while,
with some need to validate shader using Wave Intrinsics,
I wrote a hello world as a playground.
To keep things simple, here are some decisions made in advance.
 Wave Intrinsics  DirectX 12 Shader Model 6.0+  DirectXShaderCompiler (DXC)     Minimal setup  Console program  No window No swapchain No render loop   Compute Shader only No descriptor heap Minimum abstraction No error handling (except shader compilation)   Debugging  Read back output through UAV printf    Result Here is the repo ComputeShaderPlayground on Github.</description>
            <content type="html"><![CDATA[<p>After work with DirectX 12 for a while,<br>
with some need to validate shader using <a href="https://github.com/Microsoft/DirectXShaderCompiler/wiki/Wave-Intrinsics"><strong>Wave Intrinsics</strong></a>,<br>
I wrote a hello world as a playground.</p>
<p>To keep things simple, here are some decisions made in advance.</p>
<ul>
<li>Wave Intrinsics
<ul>
<li>DirectX 12</li>
<li>Shader Model 6.0+
<ul>
<li>DirectXShaderCompiler (DXC)</li>
</ul>
</li>
</ul>
</li>
<li>Minimal setup
<ul>
<li>Console program
<ul>
<li>No window</li>
<li>No swapchain</li>
<li>No render loop</li>
</ul>
</li>
<li>Compute Shader only</li>
<li>No descriptor heap</li>
<li>Minimum abstraction</li>
<li>No error handling (except shader compilation)</li>
</ul>
</li>
<li>Debugging
<ul>
<li>Read back output through UAV</li>
<li>printf</li>
</ul>
</li>
</ul>
<h3 id="result">Result</h3>
<p>Here is the repo <a href="https://github.com/silvesthu/ComputeShaderPlayground">ComputeShaderPlayground</a> on Github.<br>
With only a cpp and a hlsl each.<br>
Suprisingly, console program run just well.</p>
<p>The hlsl is just a placeholder, and structure of cpp is like</p>
<ul>
<li>Compile shader file to <code>IDxcBlob</code></li>
<li>Initialize DirectX 12 with <code>IDXGIFactory4</code> -&gt; <code>IDXGIAdapter1</code> -&gt; <code>ID3D12Device2</code></li>
<li>Create resources with <code>ID3D12Device2</code>
<ul>
<li><code>ID3D12CommandQueue</code></li>
<li><code>ID3D12CommandAllocator</code></li>
<li><code>ID3D12GraphicsCommandList</code></li>
<li><code>ID3D12RootSignature</code> -&gt; <code>ID3D12PipelineState</code></li>
<li><code>ID3D12Resource</code> as UAV</li>
<li><code>ID3D12Resource</code> as Readback</li>
</ul>
</li>
<li>Execute
<ul>
<li><code>SetComputeRootSignature</code></li>
<li><code>SetPipelineState</code></li>
<li><code>Dispatch</code></li>
<li>Copy UAV to Readback</li>
</ul>
</li>
<li>Print
<ul>
<li>Wait for GPU with <code>ID3D12Fence</code></li>
<li>Lock Readback and print its content</li>
</ul>
</li>
</ul>
<h3 id="disassembly--shader-analayzer">Disassembly &amp; Shader Analayzer</h3>
<p>Not quite related to the hello world itself though,<br>
it is rather useful (also fun) to see how code is generated.<br>
To be able to throw shader file directly into analyzer,<br>
root signature is moved from cpp into HLSL.</p>
<p><a href="http://shader-playground.timjones.io/">Shader Playground</a> provides most functionalities,<br>
however it does not support shader analyzers for Shader Model 6.0+ yet.</p>
<p><a href="https://github.com/jbarczak/pyramid">Pyramid</a> is another choice.<br>
But as RGA requires AMD card for DX12 analysis,<br>
it turn to offline mode for Vulkan with HLSL-&gt;SPIR-V which may not reflect original code.</p>
<h3 id="work-with-profiler">Work with profiler</h3>
<p>It's not too surprising that Nsight won't capture this console program.<br>
So I created a branch <a href="https://github.com/silvesthu/ComputeShaderPlayground/tree/swap_chain">swap_chain</a>,<br>
which has a dummy swap chain on console window, and a loop to presents frames.</p>
<h3 id="reference">Reference</h3>
<ul>
<li><a href="https://github.com/microsoft/DirectX-Graphics-Samples">DirectX-Graphics-Samples</a>
<ul>
<li>Official samples by features</li>
<li>Abstraction and error handling make code difficult to read</li>
</ul>
</li>
<li><a href="https://www.3dgep.com/learning-directx-12-1">Learning DirectX 12 – Lesson 1 – Initialize DirectX 12</a>
<ul>
<li>A thorough tutorial (even topics like resize, fullscreen, dpi are well covered)</li>
<li>A bit too long for lesson 1</li>
</ul>
</li>
<li><a href="https://asawicki.info/news_1719_two_shader_compilers_of_direct3d_12">Two Shader Compilers of Direct3D 12</a>
<ul>
<li>Usage of dxc and fxc, both online and offline</li>
</ul>
</li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
